// Prisma schema for Automation Platform
// Database: PostgreSQL 16

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Users table
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  username  String   @unique
  password  String   // bcrypt hashed
  firstName String?
  lastName  String?
  isActive  Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lastLogin DateTime?

  // Relations
  roles     UserRole[]
  sessions  Session[]
  auditLogs AuditLog[]

  @@map("users")
}

// Roles table
model Role {
  id          String   @id @default(uuid())
  name        String   @unique // admin, operator, viewer
  description String?
  permissions Json     // Array of permission strings

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users UserRole[]

  @@map("roles")
}

// User-Role junction table (many-to-many)
model UserRole {
  id     String @id @default(uuid())
  userId String
  roleId String

  assignedAt DateTime @default(now())
  assignedBy String? // User ID who assigned the role

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@map("user_roles")
}

// Session/Refresh tokens
model Session {
  id           String   @id @default(uuid())
  userId       String
  refreshToken String   @unique
  userAgent    String?
  ipAddress    String?
  expiresAt    DateTime

  createdAt DateTime @default(now())
  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// Modules registry
model Module {
  id               String   @id @default(uuid())
  name             String   @unique // kebab-case identifier
  version          String
  displayName      String
  description      String?
  author           String?
  status           ModuleStatus @default(REGISTERED)

  // Module manifest (complete manifest.json)
  manifest         Json

  // Module configuration (user-provided config values)
  config           Json?

  // Module file path (relative to modules directory)
  path             String?

  // Lifecycle timestamps
  installedAt      DateTime?
  enabledAt        DateTime?
  disabledAt       DateTime?
  updatedAt        DateTime @updatedAt
  createdAt        DateTime @default(now())

  // Relations
  dependencies     ModuleDependency[] @relation("DependentModule")
  dependents       ModuleDependency[] @relation("RequiredModule")
  jobs             Job[]

  @@index([status])
  @@map("modules")
}

// Module dependencies (tracks module-to-module dependencies)
model ModuleDependency {
  id              String   @id @default(uuid())
  moduleId        String   // Module that depends on another
  dependsOnId     String   // Module that is required
  versionRange    String   // Semver range (e.g., "^1.0.0")

  createdAt       DateTime @default(now())

  module          Module   @relation("DependentModule", fields: [moduleId], references: [id], onDelete: Cascade)
  dependsOn       Module   @relation("RequiredModule", fields: [dependsOnId], references: [id], onDelete: Restrict)

  @@unique([moduleId, dependsOnId])
  @@map("module_dependencies")
}

enum ModuleStatus {
  REGISTERED
  INSTALLING
  INSTALLED
  ENABLING
  ENABLED
  DISABLING
  DISABLED
  UPDATING
  REMOVING
  ERROR
}

// Audit logs
model AuditLog {
  id       String   @id @default(uuid())
  userId   String?
  action   String   // Action performed
  resource String   // Resource affected
  outcome  String   // success, failure
  details  Json?    // Additional context

  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// Phase 3: Job Scheduling System
// Job definitions (what jobs exist and their configuration)
model Job {
  id          String   @id @default(uuid())
  name        String
  description String?
  moduleId    String
  handler     String   // Path to handler function in module
  schedule    String?  // Cron expression (null if manual only)
  enabled     Boolean  @default(true)
  timeout     Int      @default(300000) // 5 minutes default
  retries     Int      @default(3)
  config      Json?    // Job-specific configuration

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // User ID who created the job

  // Relations
  module      Module           @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  executions  JobExecution[]
  schedules   JobSchedule[]

  @@index([moduleId])
  @@index([enabled])
  @@map("jobs")
}

// Job execution history (individual runs of jobs)
model JobExecution {
  id          String              @id @default(uuid())
  jobId       String
  status      JobExecutionStatus  @default(PENDING)
  startedAt   DateTime            @default(now())
  completedAt DateTime?
  duration    Int?                // milliseconds
  result      Json?               // Execution result
  error       String?             // Error message if failed
  logs        String?             // Execution logs

  job         Job                 @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([status])
  @@index([startedAt])
  @@index([jobId, status]) // Composite index for common query pattern
  @@index([status, startedAt]) // For getting recent executions by status
  @@map("job_executions")
}

// Job schedules (cron-based scheduling)
model JobSchedule {
  id          String   @id @default(uuid())
  jobId       String
  schedule    String   // Cron expression
  timezone    String   @default("UTC")
  nextRun     DateTime?
  lastRun     DateTime?
  enabled     Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([enabled])
  @@index([nextRun])
  @@map("job_schedules")
}

// Event system (pub/sub for module communication)
model Event {
  id        String   @id @default(uuid())
  name      String   // Event name (e.g., "electricity.consumption.high")
  source    String   // Module name or "system"
  payload   Json     // Event data
  createdAt DateTime @default(now())

  @@index([name])
  @@index([source])
  @@index([createdAt])
  @@index([name, createdAt]) // Composite for filtering events by name and time
  @@map("events")
}

enum JobExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  TIMEOUT
  CANCELLED
}

// Phase 4: Consumption Monitor
// Power meter endpoints (PDUs, smart meters, etc.)
model Endpoint {
  id           String   @id @default(uuid())
  name         String   // "Rack A3 PDU" or "Client XYZ Meter"
  ipAddress    String   // IP address of web interface
  type         String   // "PDU", "PowerMeter", "SmartPlug", "Custom"
  vendor       String?  // "APC", "Raritan", "Generic", etc.
  location     String?  // Physical location (e.g., "Hall 1, Row 3, Rack A3")
  clientName   String?  // Client identifier if tracking per-client

  // Authentication configuration
  authType     String   @default("none") // "none", "basic", "form", "custom"
  authConfig   Json?    // { username, password, loginUrl, etc. }

  // Scraping configuration - supports multi-step navigation
  scrapingConfig Json   // { steps: [{action, selector, value}], valueSelector, valuePattern }

  enabled      Boolean  @default(true)
  pollInterval Int      @default(15) // Minutes between readings

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  lastReadAt   DateTime? // Last successful reading

  // Relations
  readings     ConsumptionReading[]

  @@index([enabled])
  @@index([clientName])
  @@map("endpoints")
}

// Consumption readings (time-series data) - will be converted to TimescaleDB hypertable
model ConsumptionReading {
  id           String   @id @default(uuid())
  endpointId   String
  timestamp    DateTime @default(now())

  // Consumption data
  totalKwh     Float?   // Total cumulative consumption in kWh
  currentKwh   Float?   // Current month usage (calculated delta)

  // Optional instantaneous metrics
  voltage      Float?   // Volts
  current      Float?   // Amperes
  power        Float?   // Watts
  powerFactor  Float?   // Power factor (0-1)

  // Metadata
  success      Boolean  @default(true)
  errorMessage String?  // Error if scraping failed
  rawData      Json?    // Store raw scraped data for debugging

  endpoint     Endpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@index([endpointId])
  @@index([timestamp])
  @@index([endpointId, timestamp])
  @@map("consumption_readings")
}

// ============================================================================
// Module Migration Tracking
// ============================================================================

// User preferences (dashboard layout, settings, etc.)
model UserPreference {
  id        String   @id @default(uuid())
  userId    String
  key       String   // preference key (e.g., "dashboard_layout")
  value     String   // JSON string value

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, key])
  @@index([userId])
  @@map("user_preferences")
}

// Tracks which migrations have been applied for each module
model ModuleMigration {
  id          String   @id @default(uuid())
  moduleName  String   // Module identifier (kebab-case)
  version     String   // Module version when migration was applied
  filename    String   // Migration filename (e.g., "001_create_tables.sql")
  checksum    String   // SHA-256 hash of migration file content
  appliedAt   DateTime @default(now())
  appliedBy   String?  // User ID who triggered the migration (if available)
  success     Boolean  @default(true)
  error       String?  // Error message if migration failed
  executionTime Int?   // Migration execution time in milliseconds

  @@unique([moduleName, filename])
  @@index([moduleName])
  @@index([appliedAt])
  @@map("module_migrations")
}

// ============================================================================
// Documentation Manager Module
// ============================================================================

// Document categories
model DocumentCategory {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  icon        String?
  order       Int      @default(0)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  folders     DocumentFolder[]
  documents   Document[]
  permissions DocumentCategoryPermission[]

  @@map("document_categories")
}

// Hierarchical folder structure
model DocumentFolder {
  id          String   @id @default(uuid())
  name        String
  categoryId  String   @map("category_id")
  parentId    String?  @map("parent_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  category    DocumentCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  parent      DocumentFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children    DocumentFolder[] @relation("FolderHierarchy")
  documents   Document[]

  @@index([categoryId])
  @@index([parentId])
  @@map("document_folders")
}

// Document status enum
enum DocumentStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

// Main documents table
model Document {
  id          String         @id @default(uuid())
  title       String
  slug        String         @unique
  content     String
  contentHtml String?        @map("content_html")
  excerpt     String?
  categoryId  String         @map("category_id")
  folderId    String?        @map("folder_id")
  authorId    String         @map("author_id")
  status      DocumentStatus @default(DRAFT)
  publishedAt DateTime?      @map("published_at")
  createdAt   DateTime       @default(now()) @map("created_at")
  updatedAt   DateTime       @updatedAt @map("updated_at")

  // Relations
  category    DocumentCategory @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  folder      DocumentFolder?  @relation(fields: [folderId], references: [id], onDelete: SetNull)
  versions    DocumentVersion[]
  attachments DocumentAttachment[]
  tags        DocumentTag[]
  permissions DocumentPermission[]

  @@index([categoryId])
  @@index([folderId])
  @@index([slug])
  @@index([status])
  @@index([authorId])
  @@map("documents")
}

// Permission levels enum
enum DocumentPermissionLevel {
  VIEW
  EDIT
  ADMIN
}

// Category-level permissions
model DocumentCategoryPermission {
  id         String                  @id @default(uuid())
  categoryId String                  @map("category_id")
  userId     String?                 @map("user_id")
  permission DocumentPermissionLevel
  createdAt  DateTime                @default(now()) @map("created_at")

  // Relations
  category   DocumentCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([categoryId, userId])
  @@index([categoryId])
  @@map("document_category_permissions")
}

// Document-level permissions
model DocumentPermission {
  id         String                  @id @default(uuid())
  documentId String                  @map("document_id")
  userId     String?                 @map("user_id")
  permission DocumentPermissionLevel
  createdAt  DateTime                @default(now()) @map("created_at")

  // Relations
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, userId])
  @@index([documentId])
  @@map("document_permissions")
}

// Tags
model Tag {
  id        String   @id @default(uuid())
  name      String   @unique
  color     String?
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  documents DocumentTag[]

  @@map("tags")
}

// Document-Tag junction
model DocumentTag {
  id         String   @id @default(uuid())
  documentId String   @map("document_id")
  tagId      String   @map("tag_id")

  // Relations
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([documentId, tagId])
  @@index([documentId])
  @@index([tagId])
  @@map("document_tags")
}

// Document versions
model DocumentVersion {
  id         String   @id @default(uuid())
  documentId String   @map("document_id")
  version    Int
  title      String
  content    String
  authorId   String   @map("author_id")
  changeNote String?  @map("change_note")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, version])
  @@index([documentId])
  @@map("document_versions")
}

// File attachments
model DocumentAttachment {
  id         String   @id @default(uuid())
  documentId String?  @map("document_id")
  filename   String
  filepath   String
  mimetype   String
  size       Int
  uploadedBy String   @map("uploaded_by")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  document   Document? @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([uploadedBy])
  @@map("document_attachments")
}
